# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: osmosis/gamm/pool-models/balancer/balancerPool.proto, osmosis/gamm/v1beta1/genesis.proto, osmosis/gamm/v1beta1/query.proto, osmosis/gamm/v1beta1/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class MsgJoinPool(betterproto.Message):
    """===================== MsgJoinPool This is really MsgJoinPoolNoSwap"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    share_out_amount: str = betterproto.string_field(3)
    token_in_maxs: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class MsgJoinPoolResponse(betterproto.Message):
    share_out_amount: str = betterproto.string_field(1)
    token_in: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class MsgExitPool(betterproto.Message):
    """===================== MsgExitPool"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    share_in_amount: str = betterproto.string_field(3)
    token_out_mins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(
        4
    )


@dataclass(eq=False, repr=False)
class MsgExitPoolResponse(betterproto.Message):
    token_out: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SwapAmountInRoute(betterproto.Message):
    """===================== MsgSwapExactAmountIn"""

    pool_id: int = betterproto.uint64_field(1)
    token_out_denom: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgSwapExactAmountIn(betterproto.Message):
    sender: str = betterproto.string_field(1)
    routes: List["SwapAmountInRoute"] = betterproto.message_field(2)
    token_in: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    token_out_min_amount: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgSwapExactAmountInResponse(betterproto.Message):
    token_out_amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class SwapAmountOutRoute(betterproto.Message):
    """===================== MsgSwapExactAmountOut"""

    pool_id: int = betterproto.uint64_field(1)
    token_in_denom: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgSwapExactAmountOut(betterproto.Message):
    sender: str = betterproto.string_field(1)
    routes: List["SwapAmountOutRoute"] = betterproto.message_field(2)
    token_in_max_amount: str = betterproto.string_field(3)
    token_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class MsgSwapExactAmountOutResponse(betterproto.Message):
    token_in_amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MsgJoinSwapExternAmountIn(betterproto.Message):
    """
    ===================== MsgJoinSwapExternAmountIn TODO: Rename to
    MsgJoinSwapExactAmountIn
    """

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_in: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    share_out_min_amount: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgJoinSwapExternAmountInResponse(betterproto.Message):
    share_out_amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MsgJoinSwapShareAmountOut(betterproto.Message):
    """===================== MsgJoinSwapShareAmountOut"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_in_denom: str = betterproto.string_field(3)
    share_out_amount: str = betterproto.string_field(4)
    token_in_max_amount: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class MsgJoinSwapShareAmountOutResponse(betterproto.Message):
    token_in_amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MsgExitSwapShareAmountIn(betterproto.Message):
    """===================== MsgExitSwapShareAmountIn"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_out_denom: str = betterproto.string_field(3)
    share_in_amount: str = betterproto.string_field(4)
    token_out_min_amount: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class MsgExitSwapShareAmountInResponse(betterproto.Message):
    token_out_amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MsgExitSwapExternAmountOut(betterproto.Message):
    """===================== MsgExitSwapExternAmountOut"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    share_in_max_amount: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgExitSwapExternAmountOutResponse(betterproto.Message):
    share_in_amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params holds parameters for the incentives module"""

    pool_creation_fee: List[
        "___cosmos_base_v1_beta1__.Coin"
    ] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the gamm module's genesis state."""

    pools: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(1)
    # will be renamed to next_pool_id in an upcoming version
    next_pool_number: int = betterproto.uint64_field(2)
    params: "Params" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class QueryPoolRequest(betterproto.Message):
    """=============================== Pool"""

    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolResponse(betterproto.Message):
    pool: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolsRequest(betterproto.Message):
    """=============================== Pools"""

    # pagination defines an optional pagination for the request.
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryPoolsResponse(betterproto.Message):
    pools: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryNumPoolsRequest(betterproto.Message):
    """=============================== NumPools"""

    pass


@dataclass(eq=False, repr=False)
class QueryNumPoolsResponse(betterproto.Message):
    num_pools: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolTypeRequest(betterproto.Message):
    """=============================== PoolType"""

    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolTypeResponse(betterproto.Message):
    pool_type: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolParamsRequest(betterproto.Message):
    """=============================== PoolParams"""

    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolParamsResponse(betterproto.Message):
    params: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalPoolLiquidityRequest(betterproto.Message):
    """=============================== PoolLiquidity"""

    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalPoolLiquidityResponse(betterproto.Message):
    liquidity: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalSharesRequest(betterproto.Message):
    """=============================== TotalShares"""

    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalSharesResponse(betterproto.Message):
    total_shares: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QuerySpotPriceRequest(betterproto.Message):
    """
    QuerySpotPriceRequest defines the gRPC request structure for a SpotPrice
    query.
    """

    pool_id: int = betterproto.uint64_field(1)
    base_asset_denom: str = betterproto.string_field(2)
    quote_asset_denom: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class QuerySpotPriceResponse(betterproto.Message):
    """
    QuerySpotPriceResponse defines the gRPC response structure for a SpotPrice
    query.
    """

    # String of the Dec. Ex) 10.203uatom
    spot_price: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountInRequest(betterproto.Message):
    """=============================== EstimateSwapExactAmountIn"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_in: str = betterproto.string_field(3)
    routes: List["SwapAmountInRoute"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountInResponse(betterproto.Message):
    token_out_amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountOutRequest(betterproto.Message):
    """=============================== EstimateSwapExactAmountOut"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    routes: List["SwapAmountOutRoute"] = betterproto.message_field(3)
    token_out: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountOutResponse(betterproto.Message):
    token_in_amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalLiquidityRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryTotalLiquidityResponse(betterproto.Message):
    liquidity: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SmoothWeightChangeParams(betterproto.Message):
    """
    Parameters for changing the weights in a balancer pool smoothly from a
    start weight and end weight over a period of time. Currently, the only
    smooth change supported is linear changing between the two weights, but
    more types may be added in the future. When these parameters are set, the
    weight w(t) for pool time `t` is the following:   t <= start_time: w(t) =
    initial_pool_weights   start_time < t <= start_time + duration:     w(t) =
    initial_pool_weights + (t - start_time) *       (target_pool_weights -
    initial_pool_weights) / (duration)   t > start_time + duration: w(t) =
    target_pool_weights
    """

    # The start time for beginning the weight change. If a parameter change /
    # pool instantiation leaves this blank, it should be generated by the
    # state_machine as the current time.
    start_time: datetime = betterproto.message_field(1)
    # Duration for the weights to change over
    duration: timedelta = betterproto.message_field(2)
    # The initial pool weights. These are copied from the pool's settings at the
    # time of weight change instantiation. The amount PoolAsset.token.amount
    # field is ignored if present, future type refactorings should just have a
    # type with the denom & weight here.
    initial_pool_weights: List["PoolAsset"] = betterproto.message_field(3)
    # The target pool weights. The pool weights will change linearly with respect
    # to time between start_time, and start_time + duration. The amount
    # PoolAsset.token.amount field is ignored if present, future type
    # refactorings should just have a type with the denom & weight here.
    target_pool_weights: List["PoolAsset"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class PoolParams(betterproto.Message):
    """
    PoolParams defined the parameters that will be managed by the pool
    governance in the future. This params are not managed by the chain
    governance. Instead they will be managed by the token holders of the pool.
    The pool's token holders are specified in future_pool_governor.
    """

    swap_fee: str = betterproto.string_field(1)
    exit_fee: str = betterproto.string_field(2)
    smooth_weight_change_params: "SmoothWeightChangeParams" = betterproto.message_field(
        3
    )


@dataclass(eq=False, repr=False)
class PoolAsset(betterproto.Message):
    """
    Pool asset is an internal struct that combines the amount of the token in
    the pool, and its balancer weight. This is an awkward packaging of data,
    and should be revisited in a future state migration.
    """

    # Coins we are talking about, the denomination must be unique amongst all
    # PoolAssets for this pool.
    token: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    # Weight that is not normalized. This weight must be less than 2^50
    weight: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class Pool(betterproto.Message):
    address: str = betterproto.string_field(1)
    id: int = betterproto.uint64_field(2)
    pool_params: "PoolParams" = betterproto.message_field(3)
    # This string specifies who will govern the pool in the future. Valid forms
    # of this are: {token name},{duration} {duration} where {token name} if
    # specified is the token which determines the governor, and if not specified
    # is the LP token for this pool.duration is a time specified as 0w,1w,2w,
    # etc. which specifies how long the token would need to be locked up to count
    # in governance. 0w means no lockup. TODO: Further improve these docs
    future_pool_governor: str = betterproto.string_field(4)
    # sum of all LP tokens sent out
    total_shares: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(5)
    # These are assumed to be sorted by denomiation. They contain the pool asset
    # and the information about the weight
    pool_assets: List["PoolAsset"] = betterproto.message_field(6)
    # sum of all non-normalized pool weights
    total_weight: str = betterproto.string_field(7)


class MsgStub(betterproto.ServiceStub):
    async def join_pool(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        share_out_amount: str = "",
        token_in_maxs: Optional[List["___cosmos_base_v1_beta1__.Coin"]] = None
    ) -> "MsgJoinPoolResponse":
        token_in_maxs = token_in_maxs or []

        request = MsgJoinPool()
        request.sender = sender
        request.pool_id = pool_id
        request.share_out_amount = share_out_amount
        if token_in_maxs is not None:
            request.token_in_maxs = token_in_maxs

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/JoinPool", request, MsgJoinPoolResponse
        )

    async def exit_pool(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        share_in_amount: str = "",
        token_out_mins: Optional[List["___cosmos_base_v1_beta1__.Coin"]] = None
    ) -> "MsgExitPoolResponse":
        token_out_mins = token_out_mins or []

        request = MsgExitPool()
        request.sender = sender
        request.pool_id = pool_id
        request.share_in_amount = share_in_amount
        if token_out_mins is not None:
            request.token_out_mins = token_out_mins

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/ExitPool", request, MsgExitPoolResponse
        )

    async def swap_exact_amount_in(
        self,
        *,
        sender: str = "",
        routes: Optional[List["SwapAmountInRoute"]] = None,
        token_in: "___cosmos_base_v1_beta1__.Coin" = None,
        token_out_min_amount: str = ""
    ) -> "MsgSwapExactAmountInResponse":
        routes = routes or []

        request = MsgSwapExactAmountIn()
        request.sender = sender
        if routes is not None:
            request.routes = routes
        if token_in is not None:
            request.token_in = token_in
        request.token_out_min_amount = token_out_min_amount

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/SwapExactAmountIn",
            request,
            MsgSwapExactAmountInResponse,
        )

    async def swap_exact_amount_out(
        self,
        *,
        sender: str = "",
        routes: Optional[List["SwapAmountOutRoute"]] = None,
        token_in_max_amount: str = "",
        token_out: "___cosmos_base_v1_beta1__.Coin" = None
    ) -> "MsgSwapExactAmountOutResponse":
        routes = routes or []

        request = MsgSwapExactAmountOut()
        request.sender = sender
        if routes is not None:
            request.routes = routes
        request.token_in_max_amount = token_in_max_amount
        if token_out is not None:
            request.token_out = token_out

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/SwapExactAmountOut",
            request,
            MsgSwapExactAmountOutResponse,
        )

    async def join_swap_extern_amount_in(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_in: "___cosmos_base_v1_beta1__.Coin" = None,
        share_out_min_amount: str = ""
    ) -> "MsgJoinSwapExternAmountInResponse":

        request = MsgJoinSwapExternAmountIn()
        request.sender = sender
        request.pool_id = pool_id
        if token_in is not None:
            request.token_in = token_in
        request.share_out_min_amount = share_out_min_amount

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/JoinSwapExternAmountIn",
            request,
            MsgJoinSwapExternAmountInResponse,
        )

    async def join_swap_share_amount_out(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_in_denom: str = "",
        share_out_amount: str = "",
        token_in_max_amount: str = ""
    ) -> "MsgJoinSwapShareAmountOutResponse":

        request = MsgJoinSwapShareAmountOut()
        request.sender = sender
        request.pool_id = pool_id
        request.token_in_denom = token_in_denom
        request.share_out_amount = share_out_amount
        request.token_in_max_amount = token_in_max_amount

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/JoinSwapShareAmountOut",
            request,
            MsgJoinSwapShareAmountOutResponse,
        )

    async def exit_swap_extern_amount_out(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_out: "___cosmos_base_v1_beta1__.Coin" = None,
        share_in_max_amount: str = ""
    ) -> "MsgExitSwapExternAmountOutResponse":

        request = MsgExitSwapExternAmountOut()
        request.sender = sender
        request.pool_id = pool_id
        if token_out is not None:
            request.token_out = token_out
        request.share_in_max_amount = share_in_max_amount

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/ExitSwapExternAmountOut",
            request,
            MsgExitSwapExternAmountOutResponse,
        )

    async def exit_swap_share_amount_in(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_out_denom: str = "",
        share_in_amount: str = "",
        token_out_min_amount: str = ""
    ) -> "MsgExitSwapShareAmountInResponse":

        request = MsgExitSwapShareAmountIn()
        request.sender = sender
        request.pool_id = pool_id
        request.token_out_denom = token_out_denom
        request.share_in_amount = share_in_amount
        request.token_out_min_amount = token_out_min_amount

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/ExitSwapShareAmountIn",
            request,
            MsgExitSwapShareAmountInResponse,
        )


class QueryStub(betterproto.ServiceStub):
    async def pools(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryPoolsResponse":

        request = QueryPoolsRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/Pools", request, QueryPoolsResponse
        )

    async def num_pools(self) -> "QueryNumPoolsResponse":

        request = QueryNumPoolsRequest()

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/NumPools", request, QueryNumPoolsResponse
        )

    async def total_liquidity(self) -> "QueryTotalLiquidityResponse":

        request = QueryTotalLiquidityRequest()

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/TotalLiquidity",
            request,
            QueryTotalLiquidityResponse,
        )

    async def pool(self, *, pool_id: int = 0) -> "QueryPoolResponse":

        request = QueryPoolRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/Pool", request, QueryPoolResponse
        )

    async def pool_type(self, *, pool_id: int = 0) -> "QueryPoolTypeResponse":

        request = QueryPoolTypeRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/PoolType", request, QueryPoolTypeResponse
        )

    async def pool_params(self, *, pool_id: int = 0) -> "QueryPoolParamsResponse":

        request = QueryPoolParamsRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/PoolParams", request, QueryPoolParamsResponse
        )

    async def total_pool_liquidity(
        self, *, pool_id: int = 0
    ) -> "QueryTotalPoolLiquidityResponse":

        request = QueryTotalPoolLiquidityRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/TotalPoolLiquidity",
            request,
            QueryTotalPoolLiquidityResponse,
        )

    async def total_shares(self, *, pool_id: int = 0) -> "QueryTotalSharesResponse":

        request = QueryTotalSharesRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/TotalShares", request, QueryTotalSharesResponse
        )

    async def spot_price(
        self,
        *,
        pool_id: int = 0,
        base_asset_denom: str = "",
        quote_asset_denom: str = ""
    ) -> "QuerySpotPriceResponse":

        request = QuerySpotPriceRequest()
        request.pool_id = pool_id
        request.base_asset_denom = base_asset_denom
        request.quote_asset_denom = quote_asset_denom

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/SpotPrice", request, QuerySpotPriceResponse
        )

    async def estimate_swap_exact_amount_in(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_in: str = "",
        routes: Optional[List["SwapAmountInRoute"]] = None
    ) -> "QuerySwapExactAmountInResponse":
        routes = routes or []

        request = QuerySwapExactAmountInRequest()
        request.sender = sender
        request.pool_id = pool_id
        request.token_in = token_in
        if routes is not None:
            request.routes = routes

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/EstimateSwapExactAmountIn",
            request,
            QuerySwapExactAmountInResponse,
        )

    async def estimate_swap_exact_amount_out(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        routes: Optional[List["SwapAmountOutRoute"]] = None,
        token_out: str = ""
    ) -> "QuerySwapExactAmountOutResponse":
        routes = routes or []

        request = QuerySwapExactAmountOutRequest()
        request.sender = sender
        request.pool_id = pool_id
        if routes is not None:
            request.routes = routes
        request.token_out = token_out

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/EstimateSwapExactAmountOut",
            request,
            QuerySwapExactAmountOutResponse,
        )


class MsgBase(ServiceBase):
    async def join_pool(
        self,
        sender: str,
        pool_id: int,
        share_out_amount: str,
        token_in_maxs: Optional[List["___cosmos_base_v1_beta1__.Coin"]],
    ) -> "MsgJoinPoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def exit_pool(
        self,
        sender: str,
        pool_id: int,
        share_in_amount: str,
        token_out_mins: Optional[List["___cosmos_base_v1_beta1__.Coin"]],
    ) -> "MsgExitPoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def swap_exact_amount_in(
        self,
        sender: str,
        routes: Optional[List["SwapAmountInRoute"]],
        token_in: "___cosmos_base_v1_beta1__.Coin",
        token_out_min_amount: str,
    ) -> "MsgSwapExactAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def swap_exact_amount_out(
        self,
        sender: str,
        routes: Optional[List["SwapAmountOutRoute"]],
        token_in_max_amount: str,
        token_out: "___cosmos_base_v1_beta1__.Coin",
    ) -> "MsgSwapExactAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def join_swap_extern_amount_in(
        self,
        sender: str,
        pool_id: int,
        token_in: "___cosmos_base_v1_beta1__.Coin",
        share_out_min_amount: str,
    ) -> "MsgJoinSwapExternAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def join_swap_share_amount_out(
        self,
        sender: str,
        pool_id: int,
        token_in_denom: str,
        share_out_amount: str,
        token_in_max_amount: str,
    ) -> "MsgJoinSwapShareAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def exit_swap_extern_amount_out(
        self,
        sender: str,
        pool_id: int,
        token_out: "___cosmos_base_v1_beta1__.Coin",
        share_in_max_amount: str,
    ) -> "MsgExitSwapExternAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def exit_swap_share_amount_in(
        self,
        sender: str,
        pool_id: int,
        token_out_denom: str,
        share_in_amount: str,
        token_out_min_amount: str,
    ) -> "MsgExitSwapShareAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_join_pool(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "share_out_amount": request.share_out_amount,
            "token_in_maxs": request.token_in_maxs,
        }

        response = await self.join_pool(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_exit_pool(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "share_in_amount": request.share_in_amount,
            "token_out_mins": request.token_out_mins,
        }

        response = await self.exit_pool(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_swap_exact_amount_in(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "routes": request.routes,
            "token_in": request.token_in,
            "token_out_min_amount": request.token_out_min_amount,
        }

        response = await self.swap_exact_amount_in(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_swap_exact_amount_out(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "routes": request.routes,
            "token_in_max_amount": request.token_in_max_amount,
            "token_out": request.token_out,
        }

        response = await self.swap_exact_amount_out(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_join_swap_extern_amount_in(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "token_in": request.token_in,
            "share_out_min_amount": request.share_out_min_amount,
        }

        response = await self.join_swap_extern_amount_in(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_join_swap_share_amount_out(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "token_in_denom": request.token_in_denom,
            "share_out_amount": request.share_out_amount,
            "token_in_max_amount": request.token_in_max_amount,
        }

        response = await self.join_swap_share_amount_out(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_exit_swap_extern_amount_out(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "token_out": request.token_out,
            "share_in_max_amount": request.share_in_max_amount,
        }

        response = await self.exit_swap_extern_amount_out(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_exit_swap_share_amount_in(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "token_out_denom": request.token_out_denom,
            "share_in_amount": request.share_in_amount,
            "token_out_min_amount": request.token_out_min_amount,
        }

        response = await self.exit_swap_share_amount_in(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.gamm.v1beta1.Msg/JoinPool": grpclib.const.Handler(
                self.__rpc_join_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgJoinPool,
                MsgJoinPoolResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/ExitPool": grpclib.const.Handler(
                self.__rpc_exit_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExitPool,
                MsgExitPoolResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/SwapExactAmountIn": grpclib.const.Handler(
                self.__rpc_swap_exact_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSwapExactAmountIn,
                MsgSwapExactAmountInResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/SwapExactAmountOut": grpclib.const.Handler(
                self.__rpc_swap_exact_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSwapExactAmountOut,
                MsgSwapExactAmountOutResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/JoinSwapExternAmountIn": grpclib.const.Handler(
                self.__rpc_join_swap_extern_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgJoinSwapExternAmountIn,
                MsgJoinSwapExternAmountInResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/JoinSwapShareAmountOut": grpclib.const.Handler(
                self.__rpc_join_swap_share_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgJoinSwapShareAmountOut,
                MsgJoinSwapShareAmountOutResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/ExitSwapExternAmountOut": grpclib.const.Handler(
                self.__rpc_exit_swap_extern_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExitSwapExternAmountOut,
                MsgExitSwapExternAmountOutResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/ExitSwapShareAmountIn": grpclib.const.Handler(
                self.__rpc_exit_swap_share_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExitSwapShareAmountIn,
                MsgExitSwapShareAmountInResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def pools(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryPoolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def num_pools(self) -> "QueryNumPoolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def total_liquidity(self) -> "QueryTotalLiquidityResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pool(self, pool_id: int) -> "QueryPoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pool_type(self, pool_id: int) -> "QueryPoolTypeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pool_params(self, pool_id: int) -> "QueryPoolParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def total_pool_liquidity(
        self, pool_id: int
    ) -> "QueryTotalPoolLiquidityResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def total_shares(self, pool_id: int) -> "QueryTotalSharesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def spot_price(
        self, pool_id: int, base_asset_denom: str, quote_asset_denom: str
    ) -> "QuerySpotPriceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def estimate_swap_exact_amount_in(
        self,
        sender: str,
        pool_id: int,
        token_in: str,
        routes: Optional[List["SwapAmountInRoute"]],
    ) -> "QuerySwapExactAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def estimate_swap_exact_amount_out(
        self,
        sender: str,
        pool_id: int,
        routes: Optional[List["SwapAmountOutRoute"]],
        token_out: str,
    ) -> "QuerySwapExactAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_pools(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.pools(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_num_pools(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.num_pools(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_total_liquidity(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.total_liquidity(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_pool(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
        }

        response = await self.pool(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_pool_type(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
        }

        response = await self.pool_type(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_pool_params(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
        }

        response = await self.pool_params(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_total_pool_liquidity(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
        }

        response = await self.total_pool_liquidity(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_total_shares(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
        }

        response = await self.total_shares(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_spot_price(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
            "base_asset_denom": request.base_asset_denom,
            "quote_asset_denom": request.quote_asset_denom,
        }

        response = await self.spot_price(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_estimate_swap_exact_amount_in(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "token_in": request.token_in,
            "routes": request.routes,
        }

        response = await self.estimate_swap_exact_amount_in(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_estimate_swap_exact_amount_out(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "routes": request.routes,
            "token_out": request.token_out,
        }

        response = await self.estimate_swap_exact_amount_out(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.gamm.v1beta1.Query/Pools": grpclib.const.Handler(
                self.__rpc_pools,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolsRequest,
                QueryPoolsResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/NumPools": grpclib.const.Handler(
                self.__rpc_num_pools,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryNumPoolsRequest,
                QueryNumPoolsResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/TotalLiquidity": grpclib.const.Handler(
                self.__rpc_total_liquidity,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTotalLiquidityRequest,
                QueryTotalLiquidityResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/Pool": grpclib.const.Handler(
                self.__rpc_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolRequest,
                QueryPoolResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/PoolType": grpclib.const.Handler(
                self.__rpc_pool_type,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolTypeRequest,
                QueryPoolTypeResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/PoolParams": grpclib.const.Handler(
                self.__rpc_pool_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolParamsRequest,
                QueryPoolParamsResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/TotalPoolLiquidity": grpclib.const.Handler(
                self.__rpc_total_pool_liquidity,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTotalPoolLiquidityRequest,
                QueryTotalPoolLiquidityResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/TotalShares": grpclib.const.Handler(
                self.__rpc_total_shares,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTotalSharesRequest,
                QueryTotalSharesResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/SpotPrice": grpclib.const.Handler(
                self.__rpc_spot_price,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySpotPriceRequest,
                QuerySpotPriceResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/EstimateSwapExactAmountIn": grpclib.const.Handler(
                self.__rpc_estimate_swap_exact_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySwapExactAmountInRequest,
                QuerySwapExactAmountInResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/EstimateSwapExactAmountOut": grpclib.const.Handler(
                self.__rpc_estimate_swap_exact_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySwapExactAmountOutRequest,
                QuerySwapExactAmountOutResponse,
            ),
        }


from ....cosmos.base import v1beta1 as ___cosmos_base_v1_beta1__
from ....cosmos.base.query import v1beta1 as ___cosmos_base_query_v1_beta1__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
